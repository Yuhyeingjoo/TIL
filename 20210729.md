- Ch6 Runtime Polymorphism
	- Using interface, object and inheritance
	- 코드 위주의 개념 공부, C++ 클래스와 상속 

## Interface 
- Interface is a shared boundary that contains just frames, no data.
	- Function signatures, variables.
~~~c
	struct Logger{
		virtual ~Logger() = default;
		virtual void method(){}
		
		int any_sibiling_use_it= 10;
		private:
			int nono = 1;
	}

	struct PrintLogger : Logger{
		void method override(){}		
	}

	struct FileLogger : Logger{
		void method override(){}		
	}
~~~ 

- PrintLogger inherits the Logger struct.
- It overrides the method.
- Logger type의 변수에 PrintLogger 타입의 객체가 assign될 수 있다.(반대는 불가능)
- The parent class inherits member variables.
- Chils class can directly access public members but not private members. 
- virtual method 멤버함수로 갖는 클래스는 객체를 생성할 수 있지만,  virtual f_name(argu1, argu2 ) =0;
과 같은 형태를(=0;을 포함한 method 선언)  멤버로 갖는 클래스는 객체 생성 불가능하다.

## Polymorphism using classes.
- 공통되는 멤버 변수가 있으며, 로직은 비슷하지만 형식이 조금씩 다른 함수가 많은 코드의 경우.
- 모든 경우에 새로 클래스를 만들 필요 없이, interface와 inheritance를 이용해서 재사용성을 높이고 코드를 간결하게 한다.

~~~c
// 위에서 쓴 Logger코드를 예시로,
	struct Bank(){
		void set_log(Logger* new_log){
		log = new_log
		}

		void transfer(){
			log->method();
		}
		
		private:
			Logger* log;
	}
	int main(){
		Bank bank;
		bank.set_log(struct PrintLogger);
		bank.transfer();
		bank.set_log(struct FileLogger);
		bank.transfer();	
	}
~~~
